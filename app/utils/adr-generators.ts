import type { Platform, DependencyTool, DocumentationTool, CICDTool } from "~/types/project";
import type { Architecture } from "~/data/project-types";
import { getDependencyToolDocumentationUrl } from "~/data/dependency-tools";
import { getDocumentationToolUrl } from "~/data/documentation-tools";
import { getCICDToolDocumentationUrl } from "~/data/ci-cd-tools";
import {
  getDependencyTechnicalConsiderations,
  getDependencyPositiveConsequences,
  getDependencyNegativeConsequences,
  getDependencyImplementationEffort,
  getDependencyTrainingRequirements,
  getDependencyImplementationSteps,
  getDependencyAlternativesConsidered
} from "~/utils/dependency-utils";
import {
  getDocumentationTechnicalConsiderations,
  getDocumentationPositiveConsequences,
  getDocumentationNegativeConsequences,
  getDocumentationImplementationEffort,
  getDocumentationTrainingRequirements,
  getDocumentationImplementationSteps,
  getDocumentationAlternativesConsidered
} from "~/utils/documentation-utils";
import {
  getEcosystemBenefits,
  getTeamFamiliarityNotes,
  getTechnicalConsiderations,
  getPositiveConsequences,
  getNegativeConsequences,
  getCIGuidance,
  getAlternativesConsidered
} from "~/utils/platform-utils";

export const generateADR = (
  projectName: string,
  selectedPlatform: string,
  platforms: Platform[]
): string => {
  const repoName = projectName.trim() || "my-project"
  const platform = platforms.find(p => p.id === selectedPlatform)
  const currentDate = new Date().toISOString().split('T')[0]
  const adrNumber = "001" // Could be made dynamic based on existing ADRs
  
  return `# ADR-${adrNumber}: Code Hosting Platform Selection for ${repoName}

## Status
Accepted

## Date
${currentDate}

## Context
We need to select a code hosting platform for the ${repoName} project. This decision will impact our development workflow, collaboration processes, CI/CD capabilities, and integration options.

## Decision
We have decided to use **${platform?.name}** as our code hosting platform.

## Rationale
### Platform Overview
${platform?.description}

### Key Benefits
- **Best suited for**: ${platform?.bestFor}
- **Ecosystem integration**: ${getEcosystemBenefits(selectedPlatform)}
- **Team familiarity**: ${getTeamFamiliarityNotes(selectedPlatform)}

### Technical Considerations
${getTechnicalConsiderations(selectedPlatform)}

## Consequences
### Positive
- ${getPositiveConsequences(selectedPlatform).join('\n- ')}

### Negative
- ${getNegativeConsequences(selectedPlatform).join('\n- ')}

### Neutral
- Repository URL: \`${platform?.url !== '#' ? platform?.url + encodeURIComponent(repoName) : 'Self-hosted instance required'}\`
- Primary use case: Source code management and version control
- Expected team size: [To be filled]
- Project visibility: [Public/Private - To be decided]

## Implementation Notes
1. Set up repository with appropriate access controls
2. Configure branch protection rules
3. Set up CI/CD workflows ${getCIGuidance(selectedPlatform)}
4. Document contribution guidelines
5. Configure issue templates and pull request templates

## Alternatives Considered
${getAlternativesConsidered(selectedPlatform, platforms)}

## Review Date
${new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]} (90 days from decision)

---
*This ADR was generated by CreateStack.dev on ${currentDate}*`
};

export const generateDependencyADR = (
  projectName: string,
  selectedDepTool: string,
  dependencyTools: DependencyTool[]
): string => {
  const repoName = projectName.trim() || "my-project"
  const tool = dependencyTools.find(t => t.id === selectedDepTool)
  const currentDate = new Date().toISOString().split('T')[0]
  const adrNumber = "002" // Could be made dynamic based on existing ADRs
  
  return `# ADR-${adrNumber}: Dependency Management Tool Selection for ${repoName}

## Status
Accepted

## Date
${currentDate}

## Context
We need to select a dependency management tool for the ${repoName} project. This decision will impact our security posture, maintenance overhead, development workflow, and how we handle dependency updates and vulnerability management.

## Decision
We have decided to use **${tool?.name}** for dependency management.

## Rationale
### Tool Overview
${tool?.description}

### Key Benefits
- **Best suited for**: ${tool?.bestFor}
- **Platform compatibility**: ${tool?.platform}
- **Pricing model**: ${tool?.pricing}
- **Key features**: ${tool?.features.join(', ')}

### Technical Considerations
${getDependencyTechnicalConsiderations(selectedDepTool)}

## Consequences
### Positive
- ${getDependencyPositiveConsequences(selectedDepTool).join('\n- ')}

### Negative
- ${getDependencyNegativeConsequences(selectedDepTool).join('\n- ')}

### Neutral
- Documentation: ${getDependencyToolDocumentationUrl(selectedDepTool)}
- Implementation effort: ${getDependencyImplementationEffort(selectedDepTool)}
- Team training required: ${getDependencyTrainingRequirements(selectedDepTool)}

## Implementation Notes
1. ${getDependencyImplementationSteps(selectedDepTool).join('\n2. ')}

## Alternatives Considered
${getDependencyAlternativesConsidered(selectedDepTool, dependencyTools)}

## Review Date
${new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]} (90 days from decision)

---
*This ADR was generated by CreateStack.dev on ${currentDate}*`
};

export const generateDocumentationADR = (
  projectName: string,
  selectedDocTool: string,
  documentationTools: DocumentationTool[]
): string => {
  const repoName = projectName.trim() || "my-project"
  const tool = documentationTools.find(t => t.id === selectedDocTool)
  const currentDate = new Date().toISOString().split('T')[0]
  const adrNumber = "003" // Could be made dynamic based on existing ADRs
  
  return `# ADR-${adrNumber}: Documentation Platform Selection for ${repoName}

## Status
Accepted

## Date
${currentDate}

## Context
We need to select a documentation platform for the ${repoName} project. This decision will impact how we create, maintain, and share project documentation, API references, user guides, and team knowledge.

## Decision
We have decided to use **${tool?.name}** for project documentation.

## Rationale
### Platform Overview
${tool?.description}

### Key Benefits
- **Best suited for**: ${tool?.bestFor}
- **Platform compatibility**: ${tool?.platform}
- **Pricing model**: ${tool?.pricing}
- **Key features**: ${tool?.features.join(', ')}

### Technical Considerations
${getDocumentationTechnicalConsiderations(selectedDocTool)}

## Consequences
### Positive
- ${getDocumentationPositiveConsequences(selectedDocTool).join('\n- ')}

### Negative
- ${getDocumentationNegativeConsequences(selectedDocTool).join('\n- ')}

### Neutral
- Documentation URL: ${getDocumentationToolUrl(selectedDocTool)}
- Implementation effort: ${getDocumentationImplementationEffort(selectedDocTool)}
- Team training required: ${getDocumentationTrainingRequirements(selectedDocTool)}

## Implementation Notes
1. ${getDocumentationImplementationSteps(selectedDocTool).join('\n2. ')}

## Alternatives Considered
${getDocumentationAlternativesConsidered(selectedDocTool, documentationTools)}

## Review Date
${new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]} (90 days from decision)

---
*This ADR was generated by CreateStack.dev on ${currentDate}*`
};

export const generateArchitectureADR = (
  projectName: string,
  selectedArchitecture: string,
  architectures: Architecture[]
): string => {
  const repoName = projectName.trim() || "my-project"
  const architecture = architectures.find(a => a.id === selectedArchitecture)
  const currentDate = new Date().toISOString().split('T')[0]
  const adrNumber = "003" // Could be made dynamic based on existing ADRs
  
  if (!architecture) {
    return `# ADR-${adrNumber}: Architecture Pattern Selection for ${repoName}

## Status
Pending

## Date
${currentDate}

## Context
Architecture pattern selection is pending for the ${repoName} project.

---
*This ADR was generated by CreateStack.dev on ${currentDate}*`
  }
  
  return `# ADR-${adrNumber}: Architecture Pattern Selection for ${repoName}

## Status
Accepted

## Date
${currentDate}

## Context
We need to select an architecture pattern for the ${repoName} project. This decision will impact our code organization, scalability, maintainability, deployment strategy, and development workflow.

## Decision
We have decided to use **${architecture.name}** as our architecture pattern.

## Rationale
### Architecture Overview
${architecture.description}

### Key Benefits
- **Best suited for**: ${architecture.bestFor}
- **Example implementations**: ${architecture.examples.join(', ')}

### Technical Considerations
The ${architecture.name} pattern offers:
- Clear structural boundaries for development teams
- Appropriate scalability characteristics for our expected load
- Suitable complexity level for our team's expertise
- Good alignment with our chosen technology stack

## Consequences
### Positive
- Clear separation of concerns and responsibilities
- Supports team's technical expertise and project requirements
- Aligns with chosen technology stack and deployment strategy
- Provides flexibility for future scaling needs

### Negative
- Requires initial setup and configuration effort
- Team may need training on pattern-specific best practices
- May introduce additional complexity compared to simpler alternatives

### Neutral
- Architecture pattern: ${architecture.name}
- Implementation examples: ${architecture.examples.join(', ')}
- Primary use case: ${architecture.bestFor}

## Implementation Notes
1. Set up project structure according to ${architecture.name} pattern
2. Define component boundaries and interfaces
3. Establish development and deployment workflows
4. Document architecture decisions and guidelines
5. Set up monitoring and observability for the chosen pattern
6. Create templates and examples for team reference

## Alternatives Considered
${architectures.filter(a => a.id !== selectedArchitecture).map(alt => 
  `- **${alt.name}**: ${alt.description} (Best for: ${alt.bestFor})`
).join('\n')}

## Review Date
${new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]} (90 days from decision)

---
*This ADR was generated by CreateStack.dev on ${currentDate}*`
};

export const generateCICDADR = (
  projectName: string,
  selectedCICDTool: string,
  cicdTools: CICDTool[]
): string => {
  const repoName = projectName.trim() || "my-project"
  const tool = cicdTools.find(t => t.id === selectedCICDTool)
  const currentDate = new Date().toISOString().split('T')[0]
  const adrNumber = "004" // Could be made dynamic based on existing ADRs
  
  if (!tool) {
    return `# ADR-${adrNumber}: CI/CD Platform Selection for ${repoName}

## Status
Pending

## Date
${currentDate}

## Context
CI/CD platform selection is pending for the ${repoName} project.

---
*This ADR was generated by CreateStack.dev on ${currentDate}*`
  }
  
  return `# ADR-${adrNumber}: CI/CD Platform Selection for ${repoName}

## Status
Accepted

## Date
${currentDate}

## Context
We need to select a CI/CD platform for the ${repoName} project. This decision will impact our deployment automation, build processes, testing workflows, and development productivity.

## Decision
We have decided to use **${tool.name}** as our CI/CD platform.

## Rationale
### Platform Overview
${tool.description}

### Key Benefits
- **Best suited for**: ${tool.bestFor}
- **Pricing model**: ${tool.pricing}
- **Core features**: ${tool.features.join(', ')}

### Technical Considerations
${tool.name} provides:
- Integration capabilities with our chosen code hosting platform
- Scalability to meet our deployment frequency requirements
- Security features appropriate for our compliance needs
- Cost structure that aligns with our budget constraints

## Consequences
### Positive
- Automated deployment processes reduce manual errors
- Consistent build and test environments across all stages
- Faster feedback loops for development teams
- Scalable infrastructure that grows with the project
- ${tool.features.map(f => `Built-in ${f.toLowerCase()}`).join(', ')}

### Negative
- Initial setup and configuration effort required
- Team training needed for platform-specific features
- Dependency on external service availability
- Potential vendor lock-in considerations
- Ongoing costs: ${tool.pricing}

### Neutral
- CI/CD platform: ${tool.name}
- Documentation: ${getCICDToolDocumentationUrl(selectedCICDTool)}
- Platform compatibility: ${tool.platform}
- Feature set: ${tool.features.join(', ')}

## Implementation Notes
1. Set up CI/CD pipeline configuration files
2. Configure build environments and dependencies
3. Implement automated testing workflows
4. Set up deployment stages (dev, staging, production)
5. Configure secrets management and environment variables
6. Establish monitoring and alerting for build/deploy failures
7. Create documentation for team workflows
8. Set up backup and recovery procedures

## Alternatives Considered
${cicdTools.filter(t => t.id !== selectedCICDTool).map(alt => 
  `- **${alt.name}**: ${alt.description.split('.')[0]}. (Best for: ${alt.bestFor})`
).join('\n')}

## Review Date
${new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]} (90 days from decision)

---
*This ADR was generated by CreateStack.dev on ${currentDate}*`
};
